"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./types");
const utils_1 = require("./utils");
const htmlns = 'http://www.w3.org/1999/xhtml';
function serializeToString(node, buf, isHTML = false, nodeFilter, visibleNamespaces) {
    if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
            if (typeof node == 'string') {
                buf.push(node);
                return;
            }
        }
        else {
            return;
        }
        //buf.sort.apply(attrs, attributeSorter);
    }
    if (utils_1.isElement(node)) {
        if (!visibleNamespaces)
            visibleNamespaces = [];
        // const startVisibleNamespaces = visibleNamespaces.length;
        const attrs = node.attributes;
        const len = attrs.length;
        let child = node.firstChild;
        const nodeName = node.tagName;
        isHTML = htmlns === node.namespaceURI || isHTML;
        buf.push('<', nodeName);
        for (let i = 0; i < len; i++) {
            // add namespaces for attributes
            const attr = attrs.item(i);
            if (attr.prefix == 'xmlns') {
                visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            }
            else if (attr.nodeName == 'xmlns') {
                visibleNamespaces.push({ prefix: '', namespace: attr.value });
            }
        }
        for (let i = 0; i < len; i++) {
            const attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                const prefix = attr.prefix || '';
                const uri = attr.namespaceURI;
                const ns = prefix ? ' xmlns:' + prefix : ' xmlns';
                buf.push(ns, '="', uri, '"');
                visibleNamespaces.push({ prefix: prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        // add namespace for current node
        if (needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            const prefix = node.prefix || '';
            const uri = node.namespaceURI;
            const ns = prefix ? ' xmlns:' + prefix : ' xmlns';
            buf.push(ns, '="', uri, '"');
            visibleNamespaces.push({ prefix: prefix, namespace: uri });
        }
        if (child || (isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName))) {
            buf.push('>');
            //if is cdata child node
            if (isHTML && /^script$/i.test(nodeName)) {
                while (child) {
                    if (utils_1.isCharacterData(child)) {
                        buf.push(child.data);
                    }
                    else {
                        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);
                    }
                    child = child.nextSibling;
                }
            }
            else {
                while (child) {
                    serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);
                    child = child.nextSibling;
                }
            }
            buf.push('</', nodeName, '>');
        }
        else {
            buf.push('/>');
        }
        // remove added visible namespaces
        //visibleNamespaces.length = startVisibleNamespaces;
        return;
    }
    else if (utils_1.isDocument(node) || utils_1.isDocumentFragment(node)) {
        let child = node.firstChild;
        while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces);
            child = child.nextSibling;
        }
        return;
    }
    else if (utils_1.isAttr(node)) {
        return buf.push(' ', node.name, '="', node.value.replace(/[<&"]/g, _xmlEncoder), '"');
    }
    else if (utils_1.isText(node)) {
        return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));
    }
    else if (utils_1.isCDATASection(node)) {
        return buf.push('<![CDATA[', node.data, ']]>');
    }
    else if (utils_1.isComment(node)) {
        return buf.push('<!--', node.data, '-->');
    }
    else if (utils_1.isDocumentType(node)) {
        const pubid = node.publicId;
        const sysid = node.systemId;
        buf.push('<!DOCTYPE ', node.name);
        if (pubid) {
            buf.push(' PUBLIC "', pubid);
            if (sysid && sysid != '.') {
                buf.push('" "', sysid);
            }
            buf.push('">');
        }
        else if (sysid && sysid != '.') {
            buf.push(' SYSTEM "', sysid, '">');
        }
        else {
            const sub = node.internalSubset;
            if (sub) {
                buf.push(' [', sub, ']');
            }
            buf.push('>');
        }
        return;
    }
    else if (utils_1.isProcessingInstruction(node)) {
        return buf.push('<?', node.target, ' ', node.data, '?>');
    }
    else if (utils_1.isEntityReference(node)) {
        return buf.push('&', node.nodeName, ';');
    }
    else {
        buf.push('??', node.nodeName);
    }
}
exports.serializeToString = serializeToString;
function needNamespaceDefine(node, _isHTML, visibleNamespaces) {
    var prefix = node.prefix || '';
    var uri = node.namespaceURI;
    if (!prefix && !uri) {
        return false;
    }
    if ((prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace') || uri == 'http://www.w3.org/2000/xmlns/') {
        return false;
    }
    let i = visibleNamespaces.length;
    //console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
    while (i--) {
        var ns = visibleNamespaces[i];
        // get namespace prefix
        //console.log(node.nodeType,node.tagName,ns.prefix,prefix)
        if (ns.prefix == prefix) {
            return ns.namespace != uri;
        }
    }
    //console.log(isHTML,uri,prefix=='')
    //if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
    //	return false;
    //}
    //node.flag = '11111'
    //console.error(3,true,node.flag,node.prefix,node.namespaceURI)
    return true;
}
function _xmlEncoder(c) {
    return ((c == '<' && '&lt;') ||
        (c == '>' && '&gt;') ||
        (c == '&' && '&amp;') ||
        (c == '"' && '&quot;') ||
        '&#' + c.charCodeAt(0) + ';');
}
//# sourceMappingURL=serialize.js.map